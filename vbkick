#!/bin/bash

# Copyright (c) 2013-2014, Kamil Wilas (wilas.pl)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Helps build Virtualbox guest VMs and Vagrant base boxes.

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix

# For nice printing
_GREEN="\e[1;32m"
_RED="\e[1;31m"
_YELLOW="\e[1;33m"
_NORMAL="\e[0m"
__log_info() {
    printf "[INFO] ${*}\n"
}
__log_ginfo() {
    printf "${_GREEN}[INFO] ${*}${_NORMAL}\n"
}
__log_warning() {
    printf "${_YELLOW}[WARNING] ${*}${_NORMAL}\n"
}
__log_error() {
    printf "${_RED}[ERROR] ${*}${_NORMAL}\n" >&2
}

# default vm settings which may be overwritten by definition file
__load_default_settings() {
    # VM default settings - basic
    hostiocache="on"
    cpu_count=1
    memory_size=512
    disk_size=(10140)
    disk_format="vdi"
    video_memory_size=10
    # available boot devices: none|floppy|dvd|disk|net
    # there are four slots, if priovided less than 4, extra slots set to none
    # if provided more than 4, extra values are droped
    boot_order=("disk" "dvd")
    # default nic type: Intel PRO/1000 MT Desktop (82540EM); recommended - virtio
    # more to choose Am79C970A|Am79C973|82540EM|82543GC|82545EM|virtio
    # http://www.virtualbox.org/manual/ch06.html#nichardware
    nic_type="82540EM"
    # list of VM options: ("option1:value" "option2:value")
    vm_options=("ioapic:on")
    # list of VM extradata to set: ("extradata:value" "extradata:value")
    vm_extradata=("")
    # by default gui enabled unless the VirtualBox GUI is missing
    gui_enabled=1
    if ! command -v VirtualBox >/dev/null 2>&1; then
        gui_enabled=0
    fi
    # by default add one shared folder - to disable: shared_folders=("")
    shared_folders=("vbkick:%PWD%:automount")
    # by default no extra ports is mapping
    extra_ports=("")

    # Guest Additions default settings
    # set to 0 to not attach VBoxGuestAdditions iso to guest
    guest_additions_attach=1
    # path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
    guest_additions_path=""

    # Boot default settings
    #boot_file -> required option, fail if not in definition
    #boot_file_src -> required option, fail if not in definition
    # type of boot media e.g.: hdd, dvddrive; by default dvddrive
    boot_file_type="dvddrive"
    # default path for src media needed to create destination boot_file
    boot_file_src_path="iso"
    # by default checksum is empty - checksum is not check
    boot_file_src_checksum=""
    # default cheksum type is sha256
    boot_file_checksum_type="sha256"
    # by default unpacke is not needed
    boot_file_unpack_cmd=""
    # where is the path and the filename after unpack
    boot_file_unpack_name=""
    # is boot_file_src raw image and need to be converted
    boot_file_convert_from_raw=0
    # whether use cp or mv when boot_file is created form boot_file_src_file;
    # mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
    keep_boot_src_file=0
    # default time before boot_cmd_sequence start
    boot_wait=10
    # list of boot_cmd: ("cmd1" "cmd2" "cmd3")
    boot_cmd_sequence=("")
    # default number of second wait between each boot_cmd
    boot_seq_wait=1
    # default webserver port to serve kickstart files
    kickstart_port=7122
    # default max webserver live time
    kickstart_timeout=7200
    # do not start local webserver, by default 0 - mean start webserver to serve files from current dir.
    webserver_disabled=0

    # SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
    # by default use ssh keys
    ssh_keys_enabled=1
    # default user
    ssh_user="vbkick"
    # default user password - not use when ssh_keys authentication is enabled
    ssh_password="vbkick"
    # default path to ssh keys
    ssh_keys_path="keys"
    # default private key name
    ssh_priv_key="vbkick_key"
    # default auto-download path
    ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
    # default ssh host port
    ssh_host_port=2222
    # default (22) ssh guest port to forwarding
    ssh_guest_port=22
    # default "vbkickSSH"
    ssh_port_name="vbkickSSH"
    # default extra ssh and scp options
    # UserKnownHostsFile - database file to use for storing the user host keys
    # StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
    # you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
    ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

    # Lazy Postinstall default settings
    # list of files and directories to transport to guest
    postinstall_transport=("")
    # list of postinstall commands
    postinstall_launch=("")

    # Validate default settings
    # list of files and directories to transport to guest
    validate_transport=("")
    # list of validate commands
    validate_launch=("")

    # Lazy Update default settings
    # list of files and directories to transport to guest
    update_transport=("")
    # list of update commands
    update_launch=("")

    # Play default settings
    # list of files and directories to transport to guest
    play_transport=("")
    # list of play commands
    play_launch=("")

    # Clean
    # list of files to autoupdate VBOX_VERSION value
    files_to_autoupdate_vbox_version=("")
    # rm or not already transported via SCP files/directories (from postinstall, validate)
    clean_transported=0
    # nice for OS shutdown command, if not specify acpipowerbutton will be used
    shutdown_cmd=""
    # when timeout is reached and VM is still running, hard poweroff is used
    shutdown_timeout=20
}

# Global variables - do not use it in definition file (will be overwrite during program runtime)
# name of global "private" variables should start with underscore
__init_global_state_variables(){
    # 0 - webserver is not running or kill isn't able to stop it
    _webserver_state=0
    # 0 - webserver was killed cleanly or we didn't try kill it yet
    _webserver_kill_cmd_state=0
    # during exporting tmp directory is created
    _tmp_dir=""
    # during creation VM may be temporary in inconsistent state
    # e.g. not all ports mapping, options etc. were setup
    # this flag is used to make sure that vm was created completely or not at all
    _vm_creation_state=0
    # during exporting NAT mapping is removed (temporary) - help recover state before exporting
    _ssh_natmapping_was_removed=0
    # during exporting shared folders are removed (temporary) - help recover state before exporting
    _sharedfolders_removed_ptr=0
    # during exporting extra ports are removed (temporary) - help recover state before exporting
    _extraports_removed_ptr=0
}

# Display help
#@action
_usage() {
    printf "Description: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "\n"
    printf "Usage: vbkick <command> <VM_NAME> [<args>]\n"
    printf "\tversion               Print the version and exit\n"
    printf "\thelp                  Print this help\n"
    printf "\n"
    printf "Common commands:\n"
    printf "\tbuild                 Build the new VM\n"
    printf "\tpostinstall           Run postinstall scripts via SSH\n"
    printf "\tplay                  Run play commands via SSH\n"
    printf "\tvalidate              Run validate scripts via SSH\n"
    printf "\tupdate                Run update scripts via SSH\n"
    printf "\texport                Exports the VM and creates a Vagrant box - VM_NAME.box\n"
    printf "\tdestroy               Shut down and deletes the VM\n"
    printf "\tssh                   Connect to the VM via SSH\n"
    printf "\ton                    Turn on the VM\n"
    printf "\tshutdown              Shut down the VM\n"
    printf "\tclone                 Clone the VM\n"
    printf "\tlssnap                List all snapshots for a given VM\n"
    printf "\tsnap                  Take a new VM snapshot\n"
    printf "\tresnap                Restore the VM snapshot\n"
    printf "\tdelsnap               Delete the VM snapshot\n"
    printf "\tlist                  List all VirtualBox machines with the state\n"
    printf "\n"
    printf "For help on any individual command run 'vbkick <command> -h'\n"
    printf "\n"
}

#@action
_context_usage(){
    case "${1}" in
        "build")
            printf "Usage: vbkick build <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "destroy")
            printf "Usage: vbkick destroy <VM_NAME>\n" ;;
        "export")
            printf "Usage: vbkick export <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "validate")
            printf "Usage: vbkick validate <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "postinstall")
            printf "Usage: vbkick postinstall <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "play")
            printf "Usage: vbkick play <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "update")
            printf "Usage: vbkick update <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "ssh")
            printf "Usage: vbkick ssh <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "on")
            printf "Usage: vbkick on <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "shutdown")
            printf "Usage: vbkick shutdown <VM_NAME> [definition_file]\n"
            printf "If no definition file specify 'definition.cfg' is used.\n" ;;
        "clone")
            printf "Usage: vbkick clone <VM_NAME> [clone_name]\n"
            printf "If no clone name specify default one will be used - {VM_NAME}-clone{NR},\n"
            printf "where {NR} is the next available number.\n" ;;
        "snap")
            printf "Usage: vbkick snap <VM_NAME> [snapshot_name]\n"
            printf "If no snapshot name specify default one will be used - {VM_NAME}-snap{NR},\n"
            printf "where {NR} is the next available number.\n" ;;
        "resnap")
            printf "Usage: vbkick resnap <VM_NAME> [snapshot_name]\n"
            printf "If no snapshot name specify, restore to the current snapshot.\n" ;;
        "delsnap")
            printf "Usage: vbkick delsnap <VM_NAME> [snapshot_name]\n"
            printf "If no snapshot name specify, delete the current snapshot.\n" ;;
        "lssnap")
            printf "Usage: vbkick lssnap <VM_NAME>\n" ;;
        "list")
            printf "Usage: vbkick list\n" ;;
        *) _usage; exit ;;
    esac
}

#@special
_process_2_args() {
    # 2 args are required, 3 may be optional
    if [[ "${2}" == "-h" ]] || [[ "${3:-}" == "-h" ]]; then
        _context_usage "${1}"
        exit 0
    fi
    _Vm="${2}"
    case "${1}" in
        "build") _build_vm "${3:-}" ;;
        "destroy") _destroy_vm ;;
        "export") _export_vm "${3:-}" ;;
        "validate") _validate_vm "${3:-}" ;;
        "postinstall") _lazy_postinstall "${3:-}" ;;
        "play") _lazy_play "${3:-}" ;;
        "update") _lazy_update "${3:-}" ;;
        "ssh") _lazy_ssh "${3:-}" ;;
        "on") _turn_on "${3:-}" ;;
        "shutdown") _turn_off "${3:-}" ;;
        "clone") _make_clone "${3:-}" ;;
        "snap") _take_snapshot "${3:-}" ;;
        "resnap") _restore_snapshot "${3:-}" ;;
        "delsnap") _delete_snapshot "${3:-}" ;;
        "lssnap") _list_snapshots ;;
        *) _usage; exit ;;
    esac
}

#@special
_process_1_args() {
    # 1 arg is required
    case "${1}" in
        "list") _list_all_vms ;;
        "version") _prog_version ;;
        *) _usage; exit ;;
    esac
}

#@action
_prog_version(){
    printf "0.7.0-dev\n"
    exit 0
}

#@action
_list_all_vms(){
    local __lc_vm
    local __lc_state
    #list all vms and remove trailing spaces from the __lc_vm name
    VBoxManage list vms | cut -f 1 -d'{' | sed 's/[[:space:]]*$//g' | while read -r __lc_vm; do
        # get the pure __lc_vm name: "aa bb" -> aa bb
        __lc_vm="${__lc_vm//\"/}"
        # Example showvminfo output: "State:           powered off (since 2014-04-28T00:16:26.000000000)"
        # get only the state value and trim leading and trailing spaces
        __lc_state=$(VBoxManage showvminfo "${__lc_vm}" | grep State: | cut -d' ' -f 2- | cut -d'(' -f 1 | sed 's/[[:space:]]*$//g;s/^[[:space:]]*//g')
        printf "${__lc_vm}:${__lc_state}\n"
    done
    exit 0
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
__autoupdate_files_with_vbox_version() {
    local __file
    for __file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether __file is an empty string
        if [[ -z "${__file}" ]]; then
            continue
        fi
        # check whether __file exist
        if [[ -s "${__file}" ]]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -i'' "/^#/!s/\(VBOX_VERSION\)=\"\([0-9\.]\+\)\"/\1=\"${_vb_version}\"/g" "${__file}"
        else
            printf "VBOX_VERSION=\"${_vb_version}\"\n" > "${__file}"
            printf "export VBOX_VERSION" >> "${__file}"
        fi
    done
}

__depend_check() {
    local __dep_cmd="${1}"
    local __dep_name="${2}"
    # check whether __dep_name is installed - __dep_cmd command exist
    if ! command -v ${__dep_cmd} >/dev/null 2>&1; then
        __log_error "${__dep_cmd} command doesn't exist - install '${__dep_name}' to continue."
        return 1
    fi
}

__dependencies_check() {
    __depend_check "VBoxManage" "Virtualbox"
    __depend_check "curl" "curl"
    __depend_check "ssh" "ssh-client (e.g. openssh-client)"
    __depend_check "scp" "scp-client (e.g. openssh-client)"
    __depend_check "python" "python"
    __depend_check "bash" "bash"
    __depend_check "openssl" "openssl"
    __depend_check "sed" "sed"
    __depend_check "grep" "grep"
    __depend_check "cut" "coreutils"
    __depend_check "sort" "coreutils"
    __depend_check "tail" "coreutils"
}

__check_required_settings() {
    local __opts=("boot_file" "boot_file_src" "os_type_id")
    local __opt
    for __opt in "${__opts[@]}"; do
        if [[ -z "${!__opt+x}" ]]; then
            __log_error "Required ${__opt} option is not defined."
            return 1
        fi
    done
}

# Every action which requires vm settings must use this function to load them.
__load_definition() {
    __load_default_settings
    # definition.cfg is a default definition file
    # loading definition file overwrite default settings
    local __definition_fname="${1:-definition.cfg}"
    if [[ -s "${__definition_fname}" ]]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        __log_info "Loading \"${__definition_fname}\" definition..."
        if ! . "./${__definition_fname}"; then
            __log_error "Loading failed."
            return 1
        fi
    else
        __log_error "Not existing or empty \"${__definition_fname}\" file in $(pwd). Terminating..."
        return 1
    fi
    # if someone overwrite them in definition file
    __init_global_state_variables
    _vb_version=$(__get_vb_version)
    __check_required_settings
    __autoupdate_files_with_vbox_version
}

# Get virtualbox version
__get_vb_version() {
    local __version=$(VBoxManage --version) # e.g. 4.2.12r84980
    __version=$(printf "${__version}" | sed 's/\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | tail -1)
    printf "${__version}"
}

__is_present() {
    local __pattern="${1:-\"${_Vm}\"}"
    VBoxManage list vms | grep -qw "${__pattern}"
}

__is_running() {
    VBoxManage showvminfo "${_Vm}" | grep -q "State:[[:space:]]\+running"
}

__is_powered_off() {
    VBoxManage showvminfo "${_Vm}" | grep -q "State:[[:space:]]\+powered off"
}

__is_paused() {
    VBoxManage showvminfo "${_Vm}" | grep -q "State:[[:space:]]\+paused"
}

__is_alive() {
    # Alive machine may be in paused|running state
    # Useful to change state: VBoxManage controlvm "${_Vm}" pause|resume
    local __pattern="${1:-\"${_Vm}\"}"
    VBoxManage list runningvms | grep -qw "${__pattern}"
}

__is_port_used() {
    local __port_nr="${1}"
    # () is useful to be silent
    (printf "" > /dev/tcp/127.0.0.1/${__port_nr}) 2>/dev/null
}

__is_port_present() {
    local __port_name="${1}"
    VBoxManage showvminfo "${_Vm}" | grep -w 'guest port' | grep -qw "${__port_name}"
}

__is_shared_folder_present() {
    local __folder_name="${1}"
    VBoxManage showvminfo "${_Vm}" | grep -w 'machine mapping' | grep -qw "Name: '${__folder_name}'"
}

__is_snapshot_present() {
    local __snap_name="${1}"
    VBoxManage snapshot "${_Vm}" list --machinereadable | grep -w "^SnapshotName\|SnapshotUUID" | grep -qw "${__snap_name}"
}

__has_snapshots() {
    VBoxManage snapshot "${_Vm}" list --machinereadable | grep -qw "^SnapshotName"
}

# checks whether port is not used by other proc
__check_port_usage() {
    local __port_nr="${1}"
    local __port_message="${2}"
    if __is_port_used ${__port_nr}; then
        __log_error "${__port_nr} port (${__port_message}) is already used by an other process."
        return 1
    fi
}

# Check whether given directory exist
__prepare_path() {
    local __path="${1}"
    local __mkdir_path="${2}"
    # Process special variables in path definition e.g. __path="%VBOXFOLDER%/%NAME%"
    local __location=$(VBoxManage list  systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^[[:space:]]*//g')
    __path=${__path//%SRCPATH%/${boot_file_src_path}}
    __path=${__path//%VBOXFOLDER%/${__location}}
    __path=${__path//%PWD%/$(pwd)}
    # get homedir - $(getent passwd UID) doesn't work for MacOS; $HOME is less portable than ~
    __path=${__path//%HOME%/~}
    __path=${__path//%NAME%/${_Vm}}
    # expand a special variable - e.g. tilde (~) and
    # strips out > characters which could clobber a file during the eval
    __path=$(eval echo "${__path//>}")
    # Creates dir if necessary
    if [[ ${__mkdir_path} -eq 1 ]] && [[ ! -z "${__path}" ]] && [[ ! -d "${__path}" ]]; then
        mkdir -p "${__path}"
    fi
    # Return __path
    printf "${__path}"
}

__curl_safe() {
    local __src="${1}"
    local __dest="${2}"
    local __statuscode=$(curl -Lkfw "%{http_code}\n" "${__src}" -o "${__dest}")
    if [[ ${__statuscode} -ne 200 ]]; then
        __log_error "${__src} status code is ${__statuscode}. Terminating..."
        return 1
    fi
}

# Downloads custom VBoxGuestAdditions if required
__download_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(__prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [[ ! -f "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" ]]; then
        local __additions_url="http://download.virtualbox.org/virtualbox/${_vb_version}/VBoxGuestAdditions_${_vb_version}.iso"
        __curl_safe "${__additions_url}" "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
    fi
    # rm useless images
    __remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
__remove_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(__prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string
    local __file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${_vb_version}" || true)
    # continue only if we have some files to remove
    if [[ -z "${__file_list}" ]]; then
        return
    fi
    __log_info "List of VBoxGuestAdditions files to remove:"
    local __file
    for __file in ${__file_list}; do
        printf "${guest_additions_path}/${__file}\n"
    done
    # to remove files ask about confirmation
    local __ans
    read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" __ans
    if [[ ${__ans} =~ ^[Yy]$ ]]; then
        for __file in ${__file_list}; do
            printf "${guest_additions_path}/${__file}\n"
            rm -f "${guest_additions_path}/${__file}"
        done
    fi
}

# Prepare installation/boot media
__download_boot_media() {
    local __boot_file_path=$(dirname "${boot_file}")
    local __boot_file_name=$(basename "${boot_file}")
    __boot_file_path=$(__prepare_path "${__boot_file_path}" 1)
    boot_file="${__boot_file_path}/${__boot_file_name}"

    # the temporary name for boot_file is last part from boot_file_src
    local __tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(__prepare_path "${boot_file_src_path}" 1)
    local __boot_file_src_file="${boot_file_src_path}/${__tmp_name}"

    # check whether boot file exist
    if [[ -f "${boot_file}" ]]; then
        # if boot_file is the same as __boot_file_src_file then we can verify checksum
        # NB: In definition provided is checksum for the boot_file_src which may be a different
        # than destination boot_file
        if [[ "${boot_file}" == "${__boot_file_src_file}" ]]; then
            __verify_boot_media_checksum "${boot_file}"
        fi
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [[ -z "${boot_file_src}" ]]; then
        __log_error "${boot_file} not exist and boot_file_src is empty"
        return 1
    fi

    # check whether boot_file_src exist
    if [[ ! -f "${__boot_file_src_file}" ]]; then
        __curl_safe "${boot_file_src}" "${__boot_file_src_file}"
    fi
    __verify_boot_media_checksum "${__boot_file_src_file}"

    # process unpack
    if [[ ! -z "${boot_file_unpack_cmd}" ]]; then
        __unpack_boot_media
        __boot_file_src_file="${boot_file_unpack_name}"
    fi

    __deploy_boot_media_file "${__boot_file_src_file}"
}

__verify_boot_media_checksum(){
    local __boot_file_src_file="${1}"
    # verify boot_file_src checksum if boot_file_src_checksum is provided
    if [[ -z "${boot_file_src_checksum}" ]]; then
        return
    fi
    local __get_checksum=$(openssl "${boot_file_checksum_type}" "${__boot_file_src_file}" | cut -d" " -f 2)
    if [[ "${boot_file_src_checksum}" != "${__get_checksum}" ]]; then
        __log_warning "CHECKSUM is different than expected !"
        local __ans
        read -r -p "Do you want continue? [y/N]" __ans
        if [[ ! ${__ans} =~ ^[Yy]$ ]]; then
            return 1
        fi
    else
        __log_info "CHECKSUM:${boot_file_src_checksum} is valid."
    fi
}

__unpack_boot_media(){
    # check whether boot_file_unpack_name is empty if so then error
    if [[ -z "${boot_file_unpack_name}" ]]; then
        __log_error "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify"
        return 1
    fi
    # prepare path - this is full path, must already exist in filesystem
    boot_file_unpack_name=$(__prepare_path "${boot_file_unpack_name}" 0)
    # check whether boot_file_unpack_name exist - if not then run unpack cmd
    if [[ ! -f "${boot_file_unpack_name}" ]]; then
        # prepare and run unpack cmd
        boot_file_unpack_cmd=$(__prepare_path "${boot_file_unpack_cmd}" 0)
        __log_info "${boot_file_unpack_cmd}"
        eval "${boot_file_unpack_cmd}"
    fi
}

__deploy_boot_media_file(){
    local __boot_file_src_file="${1}"
    # process convert from raw if necessary
    if [[ ${boot_file_convert_from_raw} -eq 1 ]]; then
        VBoxManage convertfromraw "${__boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            rm -f "${__boot_file_src_file}"
        fi
    else
        # check whether full path to __boot_file_src_file is same as boot_file and boot_file was already created
        if [[ -f "${boot_file}" ]]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep __boot_file_src_file; keep only boot_file
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            mv -f "${__boot_file_src_file}" "${boot_file}"
        else
            cp "${__boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
__get_priv_ssh_key() {
    # check whether keys dir exist
    if [[ ! -d "${ssh_keys_path}" ]]; then
        __log_info "Creates vbkick ssh keys directory"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [[ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]]; then
        __curl_safe "${ssh_priv_key_src}" "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

#@action
_build_vm() {
    # check whether VM already exist
    if __is_present; then
        __log_error "'${_Vm}' already exist"
        exit 1
    fi
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # check SSH port usage
    __check_port_usage ${ssh_host_port} "SSH host"
    # start simple webserver (in background)
    __start_web_server
    # download boot/iso files
    __download_boot_media
    __download_guest_additions_media
    # create VM box with given settings
    __create_box
    # host ip to connect from guest
    local __host_ip=10.0.2.2
    # start VM
    if [[ ${gui_enabled} -eq 1 ]]; then
        VBoxManage startvm --type gui "${_Vm}"  && sleep ${boot_wait}
    else
        VBoxManage startvm --type headless "${_Vm}" && sleep ${boot_wait}
    fi
    # boot VM machine
    __log_info "Sending keyboard scancodes:"
    local __boot_cmd
    for __boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [[ -z "${__boot_cmd}" ]]; then
            continue
        fi
        __boot_cmd=${__boot_cmd//%IP%/${__host_ip}}
        __boot_cmd=${__boot_cmd//%PORT%/${kickstart_port}}
        __boot_cmd=${__boot_cmd//%NAME%/${_Vm}}
        __log_info "${__boot_cmd}"
        # converts string to scancode via external python script
        local __boot_cmd_code=$(printf "${__boot_cmd}" | convert_2_scancode.py)
        # sends code to VM
        local __code
        for __code in ${__boot_cmd_code}; do
            if [[ "${__code}" == "wait" ]]; then
                sleep 1
            else
                VBoxManage controlvm "${_Vm}" keyboardputscancode ${__code}
                sleep 0.02
            fi
        done
        sleep ${boot_seq_wait}
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    __kickstart_monitoring

    # stop webserver
    __stop_web_server

    exit 0
}

__create_box() {
    # Register vm
    VBoxManage createvm --name "${_Vm}" --ostype "${os_type_id}" --register
    _vm_creation_state=1

    # Creates disks
    # Get default location for disks
    local __location=$(VBoxManage list systemproperties | grep "Default machine folder" | cut -d':' -f 2 | sed 's/^[[:space:]]*//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [[ ${#disk_size[@]} -gt 28 ]]; then
        __log_error "Too many disks in disk_size (limited to 28 disks)"
        return 1;
    fi
    if [[ "${_vb_version}" > "4.3.0" ]] || [[ "${_vb_version}" == "4.3.0" ]]; then
        VBoxManage storagectl "${_Vm}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))
    else
        VBoxManage storagectl "${_Vm}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --sataportcount $((${#disk_size[@]}+2))
    fi
    # SATA controller - add boot media
    VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local __port_nr=2
    local __disk
    for __disk in "${disk_size[@]}"; do
        if [[ -z "${__disk}" ]]; then
            continue
        fi
        VBoxManage createhd --filename "${__location}/${_Vm}/${_Vm}-${__port_nr}.${disk_format}"\
        --size ${__disk} --format "${disk_format}" --variant Standard
        VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
        --port ${__port_nr} --device 0 --type hdd --medium "${__location}/${_Vm}/${_Vm}-${__port_nr}.${disk_format}"
        __port_nr=$((__port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        if [[ ! -z "${guest_additions_path}" ]]; then
            # custom VBoxGuestAdditions
            VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
        else
            # default VBoxGuestAdditions
            VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    VBoxManage modifyvm "${_Vm}" --cpus ${cpu_count}
    # setting memory size
    VBoxManage modifyvm "${_Vm}" --memory ${memory_size}
    # setting video memory size
    VBoxManage modifyvm "${_Vm}" --vram ${video_memory_size}
    # setting bootorder
    local __bo_idx=1
    local __bo
    for __bo in "${boot_order[@]}"; do
        if [[ -z "${__bo}" ]]; then
            VBoxManage modifyvm "${_Vm}" --boot${__bo_idx} none
        else
            VBoxManage modifyvm "${_Vm}" --boot${__bo_idx} ${__bo}
        fi
        local __bo_idx=$((__bo_idx+1))
        if [[ ${__bo_idx} -eq 5 ]]; then
            break
        fi
    done
    local __i
    for ((__i=${__bo_idx}; __i<=4; __i++)); do
        VBoxManage modifyvm "${_Vm}" --boot${__i} none
    done
    # setting networking
    VBoxManage modifyvm "${_Vm}" --nic1 nat --nictype1 ${nic_type} --cableconnected1 on
    # other settings
    local __option
    for __option in "${vm_options[@]}"; do
        if [[ -z "${__option}" ]]; then
            continue
        fi
        local __key="${__option%%:*}"
        local __value="${__option##*:}"
        VBoxManage modifyvm "${_Vm}" --"${__key}" "${__value}"
    done
    # set extradata
    local __extradata
    for __extradata in "${vm_extradata[@]}"; do
        if [[ -z "${__extradata}" ]]; then
            continue
        fi
        local __key="${__extradata%%:*}"
        local __value="${__extradata##*:}"
        VBoxManage setextradata "${_Vm}" "${__key}" "${__value}"
    done

    # ssh port NAT mapping; ssh port is a special one
    if ! __is_port_present "${ssh_port_name}"; then
        VBoxManage controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # extra ports NAT mapping
    __add_extra_ports_mapping "${extra_ports[@]}"

    # add shared folders
    __add_shared_folders "${shared_folders[@]}"
    _vm_creation_state=0
}

__add_extra_ports_mapping() {
    local __lc_extra_ports=("${@}")
    local __port
    for __port in "${__lc_extra_ports[@]}"; do
        if [[ -z "${__port}" ]]; then
            continue
        fi

        local IFS=':'
        local __port_info=(${__port})
        if [[ ${#__port_info[@]} -ne 3 ]]; then
            __log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local __port_name="${__port_info[0]}"
        local __port_host="${__port_info[1]}"
        local __port_guest="${__port_info[2]}"
        # add only if port doesn't exist
        if ! __is_port_present "${__port_name}"; then
            VBoxManage controlvm "${_Vm}" natpf1 "${__port_name},tcp,,${__port_host},,${__port_guest}"
        fi
    done
}

__remove_extra_ports_mapping() {
    local __lc_extra_ports=("${@}")
    local __port
    for __port in "${__lc_extra_ports[@]}"; do
        if [[ -z "${__port}" ]]; then
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local __port_info=(${__port})
        if [[ ${#__port_info[@]} -ne 3 ]]; then
            __log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local __port_name="${__port_info[0]}"
        if __is_port_present "${__port_name}"; then
            VBoxManage controlvm "${_Vm}" natpf1 delete "${__port_name}"
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
        fi
    done
}

__add_shared_folders() {
    local __lc_shared_folders=("${@}")
    local __folder
    for __folder in "${__lc_shared_folders[@]}"; do
        if [[ -z "${__folder}" ]]; then
            continue
        fi

        local IFS=':'
        local __folder_info=(${__folder})
        if [[ ${#__folder_info[@]} -lt 2 ]]; then
            __log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        local __folder_name="${__folder_info[0]}"
        local __folder_path=$(__prepare_path "${__folder_info[1]}" 1)

        # check whether shared_folder already exist
        if __is_shared_folder_present "${__folder_name}"; then
            continue
        fi

        if [[ ${#__folder_info[@]} -eq 2 ]]; then
            __log_info "VBoxManage sharedfolder add  \"${_Vm}\" --name \"${__folder_name}\" --hostpath \"${__folder_path}\""
            VBoxManage sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}"
        elif [[ ${#__folder_info[@]} -eq 3 ]]; then
            __log_info "VBoxManage sharedfolder add  \"${_Vm}\" --name \"${__folder_name}\" --hostpath \"${__folder_path}\" --${__folder_info[2]}"
            VBoxManage sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}" --"${__folder_info[2]}"
        elif [[ ${#__folder_info[@]} -eq 4 ]]; then
            __log_info "VBoxManage sharedfolder add  \"${_Vm}\" --name \"${__folder_name}\" --hostpath \"${__folder_path}\" --${__folder_info[2]} --${__folder_info[3]}"
            VBoxManage sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}" --"${__folder_info[2]}" --"${__folder_info[3]}"
        else
            __log_error "too much options in one of the shared_folders."
            return 1
        fi
    done
}

__remove_shared_folders() {
    local __lc_shared_folders=("${@}")
    local __folder
    for __folder in "${__lc_shared_folders[@]}"; do
        if [[ -z "${__folder}" ]]; then
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local __folder_info=(${__folder})
        if [[ ${#__folder_info[@]} -lt 2 ]]; then
            __log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        if [[ ${#__folder_info[@]} -gt 4 ]]; then
            __log_error "too much options in one of the shared_folders."
            return 1
        fi
        local __folder_name="${__folder_info[0]}"
        if __is_shared_folder_present "${__folder_name}"; then
            VBoxManage sharedfolder remove "${_Vm}" --name "${__folder_name}"
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
        fi
    done
}

# Check whether machine was kickstarted before timeout
__kickstart_monitoring() {
    local __kickstart_counter=0
    local __extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # create path to ssh private key
        __get_priv_ssh_key
        local __key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "\n"
        __log_info "Waiting for ssh login with user ${ssh_user} to 127.0.0.1:${ssh_host_port} to work, kickstart_timeout=${kickstart_timeout} sec"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while ! ssh "${ssh_user}@127.0.0.1" -q -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} ${__extra_ssh_options} -C "echo"\
            && [[ ${__kickstart_counter} -le ${kickstart_timeout} ]]; do
            __kickstart_counter=$((__kickstart_counter+1))
            printf "."
            sleep 1
        done
        printf "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        __log_info "Sleeping ${kickstart_timeout} seconds ..."
        sleep ${kickstart_timeout}
    fi
}

#@action
_destroy_vm() {
    # check whether VM already exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    # destroy VM
    __log_info "Destroy '${_Vm}'"
    local __ans
    read -r -p "Are you sure? [y/N]" __ans
    if [[ ! ${__ans} =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is alive
    if __is_alive; then
        __log_info "Poweroff '${_Vm}'"
        VBoxManage controlvm "${_Vm}" poweroff
        sleep 1
    fi

    __log_info "Destroying '${_Vm}'..."
    VBoxManage unregistervm "${_Vm}" --delete
    exit 0
}

#@action
_export_vm() {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${_Vm}" --output "${_Vm}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # tar command is required, check whether is installed
    __depend_check "tar" "tar"
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # check whether VM_NAME.box exist in current dir
    if [[ -f "${_Vm}.box" ]]; then
        __log_error "'${_Vm}.box' already exist in '$(pwd)'"
        exit 1
    fi
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi
    # check whether VM is running and shutdown it
    __shutdown
    if ! __is_powered_off; then
        __log_error "'${_Vm}' is not powered off. Maybe has saved state."
        __log_error "You may need to run: 'vbkick on \"${_Vm}\"' and 'vbkick shutdown \"${_Vm}\"'"
        __log_error "To check '${_Vm}' state run: 'vbkick list | grep \"${_Vm}:\"'"
        exit 1
    fi

    # clearing previously set port forwarding rules (only if exist)
    if __is_port_present "${ssh_port_name}"; then
        VBoxManage controlvm "${_Vm}" natpf1 delete "${ssh_port_name}"
        _ssh_natmapping_was_removed=1
    fi

    # rm extra ports (only if exist)
    __remove_extra_ports_mapping "${extra_ports[@]}"

    # rm shared folder (only if exist)
    __remove_shared_folders "${shared_folders[@]}"

    # create _tmp_dir for export data
    _tmp_dir=$(TMPDIR=. mktemp -d  -t 'vbkick.XXXXXXXXXX')
    # export VM to _tmp_dir
    VBoxManage export "${_Vm}" --output "${_tmp_dir}/box.ovf"
    # get VM MAC Address
    local __mac_address=$(VBoxManage showvminfo --details --machinereadable "${_Vm}"\
    | grep macaddress1 | cut -d"=" -f 2)
    # add Vagrantfile
    printf "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vbkick export\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${__mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${_tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "{\"provider\":\"virtualbox\"}\n" > "${_tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    cd ${_tmp_dir}
    tar -cvzf "${_Vm}.box" *
    cd ..
    mv "${_tmp_dir}/${_Vm}.box" .
    # remove _tmp_dir
    rm -rf ${_tmp_dir}
    # help recover some changes made on VM during exporting
    __recover_vm_state
    __log_info "Done: '$(pwd)/${_Vm}.box'"
    exit 0
}

__recover_vm_state() {
    # destroy VM as creation process was unsuccessful
    if [[ ${_vm_creation_state} -eq 1 ]]; then
        __log_info "Destroying not completed Virtual machine - '${_Vm}'"
        VBoxManage unregistervm "${_Vm}" --delete
        _vm_creation_state=0
    fi
    # add NAT mapping after exporting - only if exist prev.
    if [[ ${_ssh_natmapping_was_removed} -eq 1 ]]; then
        VBoxManage controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        _ssh_natmapping_was_removed=0
    fi
    # add extra ports after exporting - only if exist prev.
    if [[ ${_extraports_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local __lc_extra_ports=("${extra_ports[@]:0:${_extraports_removed_ptr}}")
        __add_extra_ports_mapping "${__lc_extra_ports[@]}"
        _extraports_removed_ptr=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [[ ${_sharedfolders_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local __lc_shared_folders=("${shared_folders[@]:0:${_sharedfolders_removed_ptr}}")
        __add_shared_folders "${__lc_shared_folders[@]}"
        _sharedfolders_removed_ptr=0
    fi
}

#@action
_turn_on() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doese not exist. Use 'vbkick build' to create the new VM."
        exit 1
    fi

    # check whether VM is already running
    if __is_running; then
        # nothing to do
        __log_ginfo "'${_Vm}' is already running..."
        exit 0
    elif __is_paused; then
        VBoxManage controlvm "${_Vm}" resume
        __log_info "'${_Vm}' was resumed."
        exit 0
    fi

    # load vm description/definition - needed for gui or headless
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    if [[ ${gui_enabled} -eq 1 ]]; then
        VBoxManage startvm --type gui "${_Vm}"
    else
        VBoxManage startvm --type headless "${_Vm}"
    fi
    exit 0
}

#@action
_turn_off() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doese not exist. Use 'vbkick build' to create the new VM."
        exit 1
    fi

    # check whether VM is alive
    if ! __is_alive; then
        __log_ginfo "'${_Vm}' is already turn off."
        exit 0
    fi

    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    #exec shutdown
    __shutdown
    exit 0
}

__shutdown() {
    # check whether VM is running and exec shutdown_cmd via SSH
    if [[ -n "${shutdown_cmd}" ]]; then
        if __is_running; then
            __log_info "Shutting down '${_Vm}'."
            __fix_ssh_port
            __ssh_do_launch "${shutdown_cmd}"
            __shutdown_monitoring
            sleep 3
        fi
    fi

    # check whether VM is still running, if so use acpipowerbutton
    if __is_running; then
        VBoxManage controlvm "${_Vm}" acpipowerbutton
        __log_info "Shutting down '${_Vm}' via acpipowerbutton."
        __shutdown_monitoring
        sleep 3
    fi

    # check whether VM is still alive (e.g. paused), if so poweroff it using hard way.
    if __is_alive; then
        VBoxManage controlvm "${_Vm}" poweroff
        __log_info "'${_Vm}' was powered off."
        sleep 3
    fi
    if __is_powered_off; then
        __log_info "'${_Vm}' was shutdown cleanly."
    else
        __log_warning "'${_Vm}' has different than 'powered off' state."
    fi
}

__shutdown_monitoring() {
    # wait until VM is down or shutdown_timeout was reached
    local __shutdown_counter=0
    while __is_alive && [[ ${__shutdown_counter} -le ${shutdown_timeout} ]]; do
        __shutdown_counter=$((__shutdown_counter+1))
        printf "."
        sleep 1
    done
    printf "\n"
}

__update_guest_additions_media() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist. Use \"vbkick build\" to create the new VM."
        return 1
    fi
    # get current guest version
    if VBoxManage guestproperty enumerate "${_Vm}" | grep -q "GuestAdd/Version"; then
        # guest already exist, get current version
        local __guest_version=$(VBoxManage guestproperty get "${_Vm}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local __guest_version=""
    fi

    # check whether we need update or install VBoxGuestAdditions
    if [[ "${_vb_version}" == "${__guest_version}" ]]; then
        __log_ginfo "VBoxGuestAdditions on '${_Vm}' is up-to-date - update media iso is not needed."
        return
    fi
    # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
    # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
    if ! VBoxManage showvminfo "${_Vm}" | grep -qw "SATA Controller (1, 0)"; then
        __log_error "'SATA Controller (1, 0)' for '${_Vm}' doesn't exist."
        __log_error "'SATA Controller' is sata controller name used by vbkick."
        __log_error "More: 'VBoxManage showvminfo \"${_Vm}\" | grep -w \"Controller\"'\n"
        __log_error "To create proper controller use:"
        __log_error "'VBoxManage storagectl \"${_Vm}\" --name \"SATA Controller\" --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))'"
        __log_error "'VBoxManage storageattach \"${_Vm}\" --storagectl \"SATA Controller\" --type dvddrive --port 1 --device 0 --medium emptydrive'\n"
        __log_error "To do this '${_Vm}' must be shutdown !!!"
        __log_error "Remember - VM Guest may have only one sata controller."
        return 1
    fi
    # Attach new VBoxGuestAdditions to install
    # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
    if [[ ! -z "${guest_additions_path}" ]]; then
        # custom VBoxGuestAdditions
        __download_guest_additions_media
        VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" --forceunmount
    else
        # default VBoxGuestAdditions
        VBoxManage storageattach "${_Vm}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium additions --forceunmount
    fi
    # NB: Guest OS (Linux) does not support automatic Guest Additions updating:
    # VBoxManage guestcontrol <vmname>|<uuid> updateadditions
    # Manuall Guest Additions update/installation is required (via _lazy_update cmd).
}

#@action
_validate_vm() {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"
    exit 0
}

#@action
_lazy_postinstall() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"
    exit 0
}

#@action
_lazy_play() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#play_transport[@]} "${play_transport[@]}" "${play_launch[@]}"
    exit 0
}

#@action
_lazy_update() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        __update_guest_additions_media
    fi
    # Run other update scripts on VM Guest via ssh
    __ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"
    exit 0
}

__ssh_exec() {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local __pos=${1}
    shift
    # get transport array; everything to ${__pos}
    local __transport=("${@:1:${__pos}}")
    shift ${__pos}
    # get launch array;
    local __launch=("${@}")

    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        return 1
    fi
    # check whether VM is running
    if ! __is_running; then
        __log_error "'${_Vm}' is not running..."
        return 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    __fix_ssh_port

    # check whether all pkt can by transported, before starting transporting -
    # - be a bit more atomic
    local __pkt
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]] || [[ -d "${__pkt}" ]] || [[ -f "${__pkt}" ]]; then
            continue
        else
            # __pkt is neither file nor directory
            __log_error "${__pkt} is neither file nor directory"
            return 1
        fi
    done

    # complex function shouldn't be check by 'if'; it has big consequence how function definition is processed
    # whole body of function will be executed even error occur (e.g. one of the subfunctions exit with error code 1)
    # I'm aware of this and here it's fine to check __ssh_do_transport
    if ! __ssh_do_transport "${__transport[@]}"; then
        __ssh_do_cleanup "${__transport[@]}"
        return 1
    fi
    __ssh_do_launch "${__launch[@]}"
    __ssh_do_cleanup "${__transport[@]}"
}

# try change ssh_host_port if is used a different than already configured (e.g. env variables where used)
__fix_ssh_port() {
    # port is not setup
    if ! __is_port_present "${ssh_port_name}"; then
        VBoxManage controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        return 0
    fi
    # port is setup, but host port and/or guest port are incorrect
    if ! __is_port_present "${ssh_port_name}.*host port = ${ssh_host_port}.*guest port = ${ssh_guest_port}"; then
        VBoxManage controlvm "${_Vm}" natpf1 delete "${ssh_port_name}"
        VBoxManage controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi
    # everything is correct - nothing to do.
}

__ssh_do_transport() {
    local __transport=("${@}")
    local __pkt
    # transport scripts to guest
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]]; then
            continue
        fi
        __log_info "Scp: ${__pkt}"
        # check whether __pkt is file or dir
        if [[ -d "${__pkt}" ]]; then
            # __pkt is directory
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                __get_priv_ssh_key
                local __key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${__key_path}" ${ssh_options} -r "${__pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                __auto_passwd_scp "${__pkt}" 1
            fi
        elif [[ -f "${__pkt}" ]]; then
            # __pkt is file
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                __get_priv_ssh_key
                local __key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${__key_path}" ${ssh_options} "${__pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 0 mean scp file
                __auto_passwd_scp "${__pkt}" 0
            fi
        fi
        sleep 1
    done
}

__ssh_do_launch() {
    local __launch=("${@}")
    local __cmd
    # run commands via ssh
    for __cmd in "${__launch[@]}"; do
        if [[ -z "${__cmd}" ]]; then
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${__cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            __cmd=${__cmd//%HOST%/}
            # process defined/template variables
            __cmd=$(__prepare_path "${__cmd}" 0)
            __log_info "Exec (on host): ${__cmd}"
            eval "${__cmd}"
            continue
        fi
        __log_info "Exec: ${__cmd}"
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            __get_priv_ssh_key
            local __key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} -C "${__cmd}"
        else
            __auto_passwd_ssh "${__cmd}"
        fi
        sleep 1
    done
}

__ssh_do_cleanup() {
    if [[ ${clean_transported} -eq 0 ]]; then
        return
    fi
    local __transport=("${@}")
    local __pkt
    # clean after scp by rm transported media/scripts
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]]; then
            continue
        fi
        __log_info "Clean transported: ${__pkt}"
        local __pkt_to_clean=$(basename "${__pkt}")
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            __get_priv_ssh_key
            local __key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} -C "cd ~${ssh_user} && rm -rf ${__pkt_to_clean}"
        else
            __auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${__pkt_to_clean}"
        fi
        sleep 1
    done
}

#@action
_lazy_ssh() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi
    # check whether VM is running
    if ! __is_running; then
        __log_error "'${_Vm}' is not running..."
        exit 1
    fi
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    __fix_ssh_port
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # create path to ssh private key
        __get_priv_ssh_key
        local __key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options}
    else
        __auto_passwd_ssh ""
    fi
    exit 0
}

__auto_passwd_ssh() {
    local __cmd="${1}"
    if command -v expect >/dev/null 2>&1; then
        if [[ -z "${__cmd}" ]]; then
            # No cmd to exec, interactive shell
            local __expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options}"
        else
            local __expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options} -C \"${__cmd}\""
        fi
        expect -c "log_user 0; spawn ${__expect_cmd}; expect password; send \"${ssh_password}\r\"; interact; catch wait reason; exit [lindex \$reason 3]"
    else
        __log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        __log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ -z "${__cmd}" ]]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options}
        else
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options} -C "${__cmd}"
        fi
    fi
}

__auto_passwd_scp() {
    local __src="${1}"
    local __recursive="${2}"
    if command -v expect >/dev/null 2>&1; then
        if [[ ${__recursive} -eq 1 ]]; then
            local __expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} -r \"${__src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        else
            local __expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} \"${__src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        fi
        expect -c "log_user 0; spawn ${__expect_cmd}; expect password; send \"${ssh_password}\r\"; expect eof; catch wait reason; exit [lindex \$reason 3]"
    else
        __log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        __log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ ${__recursive} -eq 1 ]]; then
            scp -q -P ${ssh_host_port} ${ssh_options} -r "${__src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        else
            scp -q -P ${ssh_host_port} ${ssh_options} "${__src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        fi
    fi
}

#@action
_make_clone(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if __is_alive; then
        __log_error "'${_Vm}' is alive. VM must be shut down to create clone."
        exit 1
    fi

    # check whether clone_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        local __clone_name="${1:-}"
        if __is_present "${__clone_name}"; then
            __log_error "'${__clone_name}' already exists."
            exit 1
        fi
    # clone_name is not provided, make the clone with auto generate name - {VM}-clone{NR++}
    elif __is_present "\"${_Vm}-clone[0-9]\+\""; then
        # clone are numered, e.g.: vm_name:aa22-snap-aa11 -> clone_name:aa22-snap-aa11-snap1..999..
        # get all clones match our clone pattern, extract NR value from each clonename, get the highes NR
        local __last_clone_nr=$(VBoxManage list vms | cut -f 1 -d'{' | grep "\"${_Vm}-clone[0-9]\+\""\
            | sed "s/${_Vm}-clone//;s/\"//g" | sort -gu | tail -1)
        __last_clone_nr=$((__last_clone_nr+1))
        local __clone_name="${_Vm}-clone${__last_clone_nr}"
    # clone with the auto generate name doesn't exist, make the first one.
    else
        local __clone_name="${_Vm}-clone1"
    fi
    VBoxManage clonevm "${_Vm}" --name "${__clone_name}" --register
    __log_info "'${_Vm}' has been cloned as '${__clone_name}'."
    exit 0
}

#@action
_take_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    # check whether snap_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        # NB: VBox allow make multiple snapshots with the same name, they are identify by UUID
        local __snap_name="${1:-}"
    # snap_name is not provided, take the snapshot with auto generate name - {VM}-snap{NR++}
    elif __is_snapshot_present "\"${_Vm}-snap[0-9]\+\""; then
        # it would be nice to use `date` but it isn't portable between linux/osx/freebsd
        # so that snapshot are numered, e.g.:
        # vm_name:aa22-snap-aa11 -> snap_name:aa22-snap-aa11-snap1..999..
        # get all snapshots match our snap pattern, extract NR value from each snapname, get the highes NR
        local __last_snap_nr=$(VBoxManage snapshot "${_Vm}" list --machinereadable | grep ^SnapshotName\
            | cut -d"=" -f 2- | grep "\"${_Vm}-snap[0-9]\+\"" | sed "s/${_Vm}-snap//;s/\"//g" | sort -gu | tail -1)
        __last_snap_nr=$((__last_snap_nr+1))
        local __snap_name="${_Vm}-snap${__last_snap_nr}"
    # snapshot with the auto generate name doesn't exist, make the first one.
    else
        local __snap_name="${_Vm}-snap1"
    fi
    VBoxManage snapshot "${_Vm}" take "${__snap_name}" --live
    __log_info "'${__snap_name}' snapshot was taken."
    exit 0
}

#@action
_restore_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi

    if __is_alive; then
        __log_error "'${_Vm}' is alive. VM must be shut down to restore snapshot."
        exit 1
    fi

    local __snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${__snap_name}" ]]; then
        if ! __is_snapshot_present "\"${__snap_name}\""; then
            __log_error "'${__snap_name}' snapshot doesn't exist for the '${_Vm}'"
            __log_error "Use 'vbkick lssnap \"${_Vm}\"' to list all available snapshots."
            exit 1
        fi
        VBoxManage snapshot "${_Vm}" restore "${__snap_name}"
        __log_info "'${__snap_name}' snapshot was restored."
        exit 0
    fi
    VBoxManage snapshot "${_Vm}" restorecurrent
    __log_info "Current snapshot was restored."
    exit 0
}

#@action
_delete_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi
    local __snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${__snap_name}" ]]; then
        if ! __is_snapshot_present "\"${__snap_name}\""; then
            __log_error "'${__snap_name}' snapshot doesn't exist for the '${_Vm}'"
            __log_error "Use 'vbkick lssnap \"${_Vm}\"' to list all available snapshots."
            exit 1
        fi
    # snap_name is not provided, remove the current snapshot
    else
        __snap_name=$(VBoxManage snapshot "${_Vm}" list --machinereadable | grep ^CurrentSnapshotUUID\
            | cut -d"=" -f 2- | sed 's/"//g')
    fi
    VBoxManage snapshot "${_Vm}" delete "${__snap_name}"
    __log_info "'${__snap_name}' snapshot was deleted."
    exit 0
}

#@action
_list_snapshots(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi
    VBoxManage snapshot "${_Vm}" list
    exit 0
}

__start_web_server() {
    # Do not start webserver - remote server is used instead to serve kickstart files.
    if [[ ${webserver_disabled} -eq 1 ]]; then
        return
    fi
    # check whether port is not used by other proc
    __check_port_usage ${kickstart_port} "kickstart"
    # start simple webserver serving files in background
    local __py_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d'.' -f 1)
    if [[ ${__py_version} -eq 2 ]]; then
        _webserver_module="SimpleHTTPServer"
    elif [[ ${__py_version} -eq 3 ]]; then
        _webserver_module="http.server"
    else
        __log_error "Unknown python version."
        return 1
    fi
    python -m ${_webserver_module} ${kickstart_port} &
    # get the pid already spawned process, to kill it later
    _web_pid=$!
    # update _webserver_state variable
    _webserver_state=1
    sleep 2
    # check whether web server was really started
    if ! __is_port_used ${kickstart_port}; then
        __log_error "webserver was not started"
        if kill -s 0 ${_web_pid} 2>/dev/null; then
            kill ${_web_pid}
        fi
        _webserver_state=0
        return 1
    fi
    __log_info "webserver has been started (pid ${_web_pid})"
}

__stop_web_server() {
    # check whether webserver is running
    if [[ ${_webserver_state} -eq 0 ]]; then
        return
    fi
    __log_info "Stopping webserver (pid ${_web_pid})"
    # with "set -e -E" if kill command fail then ERR trap is processing
    # simply execution of function is not continued
    _webserver_kill_cmd_state=1
    # check whether process exist and accept signals before sending SIGTERM
    if kill -s 0 ${_web_pid} 2>/dev/null; then
        kill ${_web_pid}
    fi
    _webserver_kill_cmd_state=0
    # update _webserver_state variable
    _webserver_state=0
    # kill command is sucessfull when SIGTERM is sent to running process
    # not when child process was really killed
    if ! ps -ef | grep "python -m ${_webserver_module} ${kickstart_port}" | grep -qv grep; then
        __log_info "webserver was stopped"
    else
        __log_warning "problem with stopping webserver. Kill process manually"
        ps -ef | grep "python -m ${_webserver_module} ${kickstart_port}" | grep -v grep
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
#@special
_clean_up() {
    __log_info "Signal handler - cleanup before exiting..."
    # run _on_exit function to make real cleaning
    exit 1
}

#@special
_on_exit(){
    # this is a finally block - exec always on exit
    if [[ ${_webserver_kill_cmd_state} -eq 0 ]]; then
        # stop webserver (only if __stop_web_server function didn't fail previuosly)
        __stop_web_server
    else
        # previuosly executed __stop_web_server function fail in killing $_web_pid
        __log_warning "problem with killing webserver (proc ${_web_pid}). Kill process manually."
    fi
    # clean _tmp_dir if exist
    if [[ -d ${_tmp_dir} ]]; then
        rm -rf ${_tmp_dir}
    fi
    # help recover some changes made on VM during exporting
    __recover_vm_state
}

#@special
_main() {
    local __args_num=$#
    # virtual machine name
    _Vm=""
    if [[ ${__args_num} -eq 1 ]]; then
        # check whether we have everything to start with vbkick
        __dependencies_check
        _process_1_args "${1}"
    elif [[ ${__args_num} -eq 2 ]] || [[ ${__args_num} -eq 3 ]]; then
        # check whether we have everything to start with vbkick
        __dependencies_check
        _vb_version=$(__get_vb_version)
        _process_2_args "${1}" "${2}" "${3:-}"
    else
        # wrong number of arguments
        _usage
        exit 1
    fi
}

## MAIN ##
# signals and errors handler
trap _clean_up SIGHUP SIGINT SIGTERM ERR
trap _on_exit EXIT

__init_global_state_variables
if [[ $# -eq 0 ]]; then
    # no arguments
    _usage
    exit 1
fi
_main "${@}"
